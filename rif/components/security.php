<?
/**
 * Main security utility for the Application
 * Used to generate UUID's and manage encryption / decryption
 */
class security{

	/*
	 * Generate random UUID
	 */
	public function genUUID() {
		return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
				mt_rand ( 0, 0xffff ),
				mt_rand ( 0, 0xffff ),
				mt_rand ( 0, 0xffff ),
				mt_rand ( 0, 0x0fff ) | 0x4000,
				mt_rand ( 0, 0x3fff ) | 0x8000,
				mt_rand ( 0, 0xffff ),
				mt_rand ( 0, 0xffff ),
				mt_rand ( 0, 0xffff )
		);
	}

	/**
	 * [genPrivateKey Generates a 320 bit private key: The SHA-1 hash function is preformed on the UNIX epoch 
	 * and an additional random 750 to 1000 bits of entropy generated by the /dev/urandom algorithm.]
	 * @return string
	 */
	public function genPrivateKey() {
		$privateKey = sha1(time().shell_exec('head -c '.mt_rand(750,1000).' < /dev/urandom'));
		return $privateKey;
	}

	/**
	 * [genPublicKey Generates a 256 bit public key: The MD5 hash function is performed on the UNIX epoch and an
	 * additional random amount of entropy from the /urandom function.]
	 * @return string
	 */
	public function genPublicKey() {
		$publicKey = md5(time().shell_exec('head -c '.mt_rand(250,350).' < /dev/urandom'));
		return $publicKey;
	}


	/**
	 * [encrypt Returns an encrypted cipherstream provided plaintext and a private key.]
	 * @param  string $plainText
	 * @param  string $privada
	 * @param  string $publica
	 * @return encrypted string
	 */
	public function encrypt($plainText, $privada, $publica) {
		$publicKey = $publica;//$this->api_key; //$this->genPublicKey();
		$privateKey = $privada; //$this->private_key;
		$textArray = str_split($plainText);

		$shiftKeyArray = array();
		for($i=0;$i<ceil(sizeof($textArray)/40);$i++) array_push($shiftKeyArray,sha1($privateKey.$i.$publicKey));

		$cipherTextArray = array();
		for($i=0;$i<sizeof($textArray);$i++)
		{
			$cipherChar = "";
			if(isset($textArray[$i])) $cipherChar .= ord($textArray[$i]);
			if(isset($shiftKeyArray[$i])) $cipherChar += ord($shiftKeyArray[$i]);
			$cipherChar -= floor($cipherChar/255)*255;
			$cipherTextArray[$i] = dechex($cipherChar);	
		}

		unset($textarray);
		unset($shiftKeyArray);
		unset($cipherChar);

		$cipherStream = implode("",$cipherTextArray);

		unset($publicKey);
		unset($cipherTextArray);

		return $cipherStream;
	}

	/**
	 * [encrypt Returns plaintext given the cipherstream and the same private key used to make it.]
	 * @param  string $plainText
	 * @param  string $privada
	 * @param  string $publica
	 * @return decrypted string
	 */
	public function decrypt($cipherStream, $privada, $publica) {
		$publicKey = $publica;
		$privateKey = $privada;

		$cipherText = $cipherStream;
		unset($cipherStream);

		$cipherTextArray = array();
		for($i=0;$i<strlen($cipherText);$i+=2) array_push($cipherTextArray,substr($cipherText,$i,2));
		unset($cipherText);

		$shiftKeyArray = array();
		for($i=0;$i<ceil(sizeof($cipherTextArray)/40);$i++) array_push($shiftKeyArray,sha1($privateKey.$i.$publicKey));
		unset($privateKey);
		unset($publicKey);

		$plainChar = null;
		$plainTextArray = array();
		for($i=0;$i<sizeof($cipherTextArray);$i++){
			$plainChar = "";
			if(isset($cipherTextArray[$i])) $plainChar .= hexdec($cipherTextArray[$i]);
			if(isset($shiftKeyArray[$i])) $plainChar -= ord($shiftKeyArray[$i]);
			$plainChar -= floor($plainChar/255)*255;
			$plainTextArray[$i] = chr($plainChar);
		}

		unset($cipherTextArray);
		unset($shiftKeyArray);
		unset($plainChar);
	
		$plainText = implode("",$plainTextArray);
		return $plainText;
	}
}
?>